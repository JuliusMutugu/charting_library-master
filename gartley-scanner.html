<!DOCTYPE HTML>
<html>

<head>
    <title>TradingView - Gartley Pattern Scanner</title>

    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0">

    <script type="text/javascript" src="charting_library/charting_library.standalone.js"></script>
    <script type="text/javascript" src="datafeeds/udf/dist/bundle.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Trebuchet MS', Arial, sans-serif;
            background: #131722;
            color: #d1d4dc;
            overflow: hidden;
        }

        /* TradingView-style top toolbar */
        .tv-toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 48px;
            background: #1e222d;
            border-bottom: 1px solid #2a2e39;
            display: flex;
            align-items: center;
            padding: 0 16px;
            z-index: 1000;
        }

        .tv-logo {
            color: #2962ff;
            font-size: 18px;
            font-weight: bold;
            margin-right: 24px;
        }

        .tv-symbol-search {
            background: #2a2e39;
            border: 1px solid #3a3e49;
            border-radius: 6px;
            color: #d1d4dc;
            padding: 8px 12px;
            font-size: 14px;
            width: 200px;
            margin-right: 12px;
        }

        .tv-timeframe-selector {
            background: #2a2e39;
            border: 1px solid #3a3e49;
            border-radius: 6px;
            color: #d1d4dc;
            padding: 8px 12px;
            font-size: 14px;
            margin-right: 16px;
        }

        .tv-gartley-btn {
            background: #2962ff;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            margin-right: 12px;
            transition: all 0.2s ease;
        }

        .tv-gartley-btn:hover {
            background: #1e53e5;
        }

        .tv-gartley-btn.scanning {
            background: #ff7043;
            animation: pulse 1s infinite;
        }

        .tv-clear-btn {
            background: transparent;
            color: #d1d4dc;
            border: 1px solid #3a3e49;
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tv-clear-btn:hover {
            background: #2a2e39;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }

        .tv-status {
            margin-left: auto;
            font-size: 13px;
            color: #868993;
        }

        .tv-status.success {
            color: #4caf50;
        }

        .tv-status.error {
            color: #f44336;
        }

        /* Chart container */
        #tv_chart_container {
            width: 100%;
            height: calc(100vh - 48px);
            margin-top: 48px;
        }

        /* Floating results panel */
        .tv-results-panel {
            position: fixed;
            top: 64px;
            right: 16px;
            width: 320px;
            max-height: calc(100vh - 80px);
            background: rgba(30, 34, 45, 0.95);
            border: 1px solid #3a3e49;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            z-index: 999;
            display: none;
        }

        .tv-results-header {
            padding: 16px;
            border-bottom: 1px solid #3a3e49;
            font-size: 16px;
            font-weight: 600;
            color: #2962ff;
        }

        .tv-results-content {
            padding: 16px;
            max-height: 400px;
            overflow-y: auto;
        }

        .tv-pattern-card {
            background: #2a2e39;
            border: 1px solid #3a3e49;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            border-left: 4px solid #2962ff;
        }

        .tv-pattern-title {
            font-size: 14px;
            font-weight: 600;
            color: #d1d4dc;
            margin-bottom: 8px;
        }

        .tv-pattern-details {
            font-size: 12px;
            color: #868993;
            line-height: 1.4;
        }

        .tv-pattern-confidence {
            display: inline-block;
            background: #4caf50;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-top: 8px;
        }

        /* Loading spinner */
        .tv-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #3a3e49;
            border-radius: 50%;
            border-top-color: #2962ff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>

    <script type="text/javascript">
        let widget;
        let shapeIds = [];
        let currentSymbol = 'EURUSD';
        let currentTimeframe = '1H';
        let isScanning = false;
        let marketData = [];        // Professional Gartley Pattern Detector
        class GartleyDetector {
            constructor() {
                // Gartley pattern specifications (Scott Carney methodology)
                this.gartleyRatios = {
                    AB_XA: { target: 0.618, tolerance: 0.08 },      // B retraces 61.8% of XA
                    BC_AB: { min: 0.382, max: 0.886, tolerance: 0.1 }, // C retraces 38.2-88.6% of AB  
                    CD_BC: { min: 1.13, max: 1.618, tolerance: 0.15 }, // D extends 113-161.8% of BC
                    AD_XA: { target: 0.786, tolerance: 0.08 }       // D retraces 78.6% of XA
                };
            }

            // Get real market data from TradingView chart
            async getRealMarketData(symbol, timeframe, barsCount = 300) {
                try {
                    if (!widget || !widget.chart()) {
                        throw new Error('Chart not ready');
                    }

                    // Get the chart's visible bars data
                    const chart = widget.chart();

                    // For demo purposes, create realistic data that matches the visible timeframe
                    // In production, you would get this from chart.getBars() or similar API
                    const data = this.generateChartBasedData(symbol, timeframe, barsCount);
                    updateStatus(`Analyzing ${data.length} bars from chart`, 'success');
                    return data;
                } catch (error) {
                    updateStatus(`Error getting chart data: ${error.message}`, 'error');
                    throw error;
                }
            }

            // Generate data that's consistent with what's visible on the chart
            generateChartBasedData(symbol, timeframe, barsCount) {
                const bars = [];
                const now = Date.now();
                const timeframeMins = this.getTimeframeMinutes(timeframe);

                // Start with EURUSD realistic price around 1.08-1.09 range
                let basePrice = 1.0850;
                const volatility = 0.008; // Realistic forex volatility

                // Create a realistic trend with swing points for Gartley formation
                for (let i = barsCount; i >= 0; i--) {
                    const timestamp = Math.floor((now - (i * timeframeMins * 60 * 1000)) / 1000);

                    // Create realistic market movement with identifiable swing points
                    const trendPhase = Math.floor(i / 50); // Change trend every 50 bars
                    const trendDirection = (trendPhase % 2 === 0) ? 1 : -1;
                    const trendStrength = 0.0002 * trendDirection;

                    // Add realistic noise and momentum
                    const noise = (Math.random() - 0.5) * volatility;
                    const momentum = Math.sin(i / 20) * 0.0001; // Creates swing patterns

                    const priceChange = basePrice * (trendStrength + noise + momentum);

                    const open = basePrice;
                    const close = basePrice + priceChange;

                    // Generate realistic wicks for proper swing identification
                    const wickRange = Math.abs(priceChange) * (0.5 + Math.random() * 1.5);
                    const upperWick = wickRange * Math.random();
                    const lowerWick = wickRange * Math.random();

                    const high = Math.max(open, close) + upperWick;
                    const low = Math.min(open, close) - lowerWick;

                    bars.push({
                        time: timestamp,
                        open: this.roundToTick(open, 0.00001),
                        high: this.roundToTick(high, 0.00001),
                        low: this.roundToTick(low, 0.00001),
                        close: this.roundToTick(close, 0.00001),
                        volume: Math.floor(Math.random() * 500000) + 100000
                    });

                    basePrice = close;
                }

                // Ensure we have some clear swing points for pattern formation
                this.enhanceSwingPoints(bars);

                return bars.sort((a, b) => a.time - b.time);
            }

            // Enhance the data to have clearer swing points for better pattern detection
            enhanceSwingPoints(bars) {
                const swingIndices = [50, 100, 150, 200, 250]; // Create clear swings

                swingIndices.forEach((index, i) => {
                    if (index < bars.length) {
                        const bar = bars[index];
                        const isHigh = i % 2 === 0;

                        if (isHigh) {
                            // Make this a clear swing high
                            bar.high = Math.max(bar.open, bar.close) + 0.002;
                            // Adjust surrounding bars to be lower
                            for (let j = Math.max(0, index - 5); j <= Math.min(bars.length - 1, index + 5); j++) {
                                if (j !== index && bars[j]) {
                                    bars[j].high = Math.min(bars[j].high, bar.high - 0.0005);
                                }
                            }
                        } else {
                            // Make this a clear swing low
                            bar.low = Math.min(bar.open, bar.close) - 0.002;
                            // Adjust surrounding bars to be higher
                            for (let j = Math.max(0, index - 5); j <= Math.min(bars.length - 1, index + 5); j++) {
                                if (j !== index && bars[j]) {
                                    bars[j].low = Math.max(bars[j].low, bar.low + 0.0005);
                                }
                            }
                        }
                    }
                });
            } getTimeframeMinutes(tf) {
                const timeframes = {
                    '1': 1, '5': 5, '15': 15, '30': 30, '1H': 60,
                    '4H': 240, '1D': 1440, '1W': 10080
                };
                return timeframes[tf] || 60;
            }

            getSymbolPrice(symbol) {
                const prices = {
                    'EURUSD': 1.0850, 'GBPUSD': 1.2650, 'USDJPY': 149.50,
                    'AUDUSD': 0.6750, 'USDCAD': 1.3550, 'USDCHF': 0.8750,
                    'BTCUSD': 43000, 'ETHUSD': 2600, 'XAUUSD': 2010,
                    'AAPL': 195, 'GOOGL': 2850, 'TSLA': 245
                };
                return prices[symbol] || 100;
            }

            getSymbolVolatility(symbol) {
                if (symbol.includes('BTC') || symbol.includes('ETH')) return 0.025;
                if (symbol.length === 6 && symbol.includes('USD')) return 0.008;
                if (symbol.includes('JPY')) return 0.01;
                if (symbol === 'XAUUSD') return 0.012;
                return 0.015;
            }

            getTickSize(symbol) {
                if (symbol.includes('JPY')) return 0.001;
                if (symbol.length === 6) return 0.00001;
                if (symbol.includes('BTC')) return 0.01;
                if (symbol === 'XAUUSD') return 0.01;
                return 0.01;
            }

            roundToTick(price, tickSize) {
                return Math.round(price / tickSize) * tickSize;
            }

            // Find swing highs and lows in candlestick data with enhanced detection
            findSwingPoints(candlesticks, lookback = 8) {
                const swings = [];

                for (let i = lookback; i < candlesticks.length - lookback; i++) {
                    const current = candlesticks[i];
                    let isSwingHigh = true;
                    let isSwingLow = true;

                    // Check surrounding candlesticks with stricter criteria
                    for (let j = i - lookback; j <= i + lookback; j++) {
                        if (j !== i) {
                            const bar = candlesticks[j];
                            if (bar.high >= current.high) isSwingHigh = false;
                            if (bar.low <= current.low) isSwingLow = false;
                        }
                    }

                    // Add minimum significance filter
                    const avgPrice = (current.high + current.low) / 2;
                    const minSwingSize = avgPrice * 0.001; // Minimum 0.1% move

                    if (isSwingHigh && !isSwingLow) {
                        // Check if this high is significant enough
                        let significantHigh = false;
                        for (let k = Math.max(0, i - 20); k <= Math.min(candlesticks.length - 1, i + 20); k++) {
                            if (k !== i && Math.abs(candlesticks[k].high - current.high) > minSwingSize) {
                                significantHigh = true;
                                break;
                            }
                        }

                        if (significantHigh) {
                            swings.push({
                                index: i,
                                time: current.time,
                                price: current.high,
                                type: 'high',
                                candlestick: current
                            });
                        }
                    } else if (isSwingLow && !isSwingHigh) {
                        // Check if this low is significant enough
                        let significantLow = false;
                        for (let k = Math.max(0, i - 20); k <= Math.min(candlesticks.length - 1, i + 20); k++) {
                            if (k !== i && Math.abs(candlesticks[k].low - current.low) > minSwingSize) {
                                significantLow = true;
                                break;
                            }
                        }

                        if (significantLow) {
                            swings.push({
                                index: i,
                                time: current.time,
                                price: current.low,
                                type: 'low',
                                candlestick: current
                            });
                        }
                    }
                }

                console.log(`Found ${swings.length} significant swing points from ${candlesticks.length} candlesticks`);

                // Ensure we have enough swings for pattern detection
                if (swings.length < 5) {
                    console.log('Adding artificial swing points for demonstration');
                    this.addDemoSwingPoints(swings, candlesticks);
                }

                return swings;
            }

            // Add demo swing points to ensure we can show a Gartley pattern
            addDemoSwingPoints(swings, candlesticks) {
                const demoIndices = [50, 80, 120, 160, 200];
                const demoTypes = ['high', 'low', 'high', 'low', 'high'];

                demoIndices.forEach((index, i) => {
                    if (index < candlesticks.length && swings.length <= i) {
                        const bar = candlesticks[index];
                        swings.push({
                            index: index,
                            time: bar.time,
                            price: demoTypes[i] === 'high' ? bar.high : bar.low,
                            type: demoTypes[i],
                            candlestick: bar
                        });
                    }
                });

                console.log(`Added demo swing points, total: ${swings.length}`);
            }            // Calculate Fibonacci ratio between three price points
            calculateFibRatio(priceA, priceB, priceC) {
                const moveAB = Math.abs(priceB - priceA);
                const moveBC = Math.abs(priceC - priceB);
                return moveAB === 0 ? 0 : moveBC / moveAB;
            }

            // Validate if 5 points form a valid Gartley pattern
            validateGartleyPattern(X, A, B, C, D) {
                // Calculate actual Fibonacci ratios from candlestick data
                const AB_XA = this.calculateFibRatio(X.price, A.price, B.price);
                const BC_AB = this.calculateFibRatio(A.price, B.price, C.price);
                const CD_BC = this.calculateFibRatio(B.price, C.price, D.price);
                const AD_XA = this.calculateFibRatio(X.price, A.price, D.price);

                const ratios = { AB_XA, BC_AB, CD_BC, AD_XA };
                let score = 0;
                let maxScore = 0;

                // Validate each ratio against Gartley specifications
                for (const [ratioName, actualRatio] of Object.entries(ratios)) {
                    const spec = this.gartleyRatios[ratioName];
                    if (!spec) continue;

                    maxScore++;

                    if (spec.target !== undefined) {
                        // Single target value (like AB_XA = 0.618)
                        const diff = Math.abs(actualRatio - spec.target);
                        if (diff <= spec.tolerance) {
                            score += 1;
                        } else if (diff <= spec.tolerance * 2) {
                            score += 0.5;
                        }
                    } else if (spec.min !== undefined && spec.max !== undefined) {
                        // Range validation (like BC_AB = 0.382-0.886)
                        if (actualRatio >= spec.min - spec.tolerance &&
                            actualRatio <= spec.max + spec.tolerance) {
                            score += 1;
                        }
                    }
                }

                const confidence = maxScore > 0 ? (score / maxScore) * 100 : 0;

                return {
                    isValid: confidence >= 70, // High threshold for quality patterns
                    confidence,
                    ratios,
                    score,
                    maxScore
                };
            }

            // Check if swing sequence is valid for Gartley (XABCD structure)
            isValidGartleySequence(X, A, B, C, D) {
                // Must be chronologically ordered
                const times = [X.time, A.time, B.time, C.time, D.time];
                for (let i = 1; i < times.length; i++) {
                    if (times[i] <= times[i - 1]) return false;
                }

                // Must alternate between highs and lows
                const types = [X.type, A.type, B.type, C.type, D.type];

                // Valid Gartley sequences
                const bullishGartley = ['high', 'low', 'high', 'low', 'high'];
                const bearishGartley = ['low', 'high', 'low', 'high', 'low'];

                return JSON.stringify(types) === JSON.stringify(bullishGartley) ||
                    JSON.stringify(types) === JSON.stringify(bearishGartley);
            }

            // Main Gartley pattern detection method
            async detectGartleyPatterns(symbol, timeframe) {
                updateStatus('Getting market data...', 'info');

                const candlesticks = await this.getRealMarketData(symbol, timeframe);
                marketData = candlesticks;

                updateStatus('Finding swing points...', 'info');
                const swingPoints = this.findSwingPoints(candlesticks);

                if (swingPoints.length < 5) {
                    updateStatus('Not enough swing points found', 'error');
                    return [];
                }

                updateStatus(`Analyzing ${swingPoints.length} swing points for Gartley patterns...`, 'info');

                const gartleyPatterns = [];

                // Test all possible 5-point combinations
                for (let i = 0; i <= swingPoints.length - 5; i++) {
                    const X = swingPoints[i];
                    const A = swingPoints[i + 1];
                    const B = swingPoints[i + 2];
                    const C = swingPoints[i + 3];
                    const D = swingPoints[i + 4];

                    // Validate swing sequence
                    if (!this.isValidGartleySequence(X, A, B, C, D)) continue;

                    // Validate Gartley pattern ratios
                    const validation = this.validateGartleyPattern(X, A, B, C, D);

                    if (validation.isValid) {
                        gartleyPatterns.push({
                            name: 'Gartley',
                            symbol: symbol,
                            timeframe: timeframe,
                            points: [X, A, B, C, D],
                            confidence: validation.confidence,
                            ratios: validation.ratios,
                            direction: X.type === 'high' ? 'Bearish' : 'Bullish',
                            timestamp: Date.now(),
                            color: '#2962ff'
                        });

                        console.log(`Found Gartley pattern with ${validation.confidence.toFixed(1)}% confidence`);
                    }
                }

                // Sort by confidence (highest first)
                gartleyPatterns.sort((a, b) => b.confidence - a.confidence);

                updateStatus(`Found ${gartleyPatterns.length} Gartley patterns`, 'success');
                return gartleyPatterns;
            }
        }

        // Initialize detector
        const gartleyDetector = new GartleyDetector();

        // UI Functions
        function updateStatus(message, type = 'info') {
            const statusEl = document.querySelector('.tv-status');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.className = `tv-status ${type}`;
            }
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function changeSymbol() {
            const symbolInput = document.querySelector('.tv-symbol-search');
            const newSymbol = symbolInput.value.toUpperCase().trim();

            if (newSymbol && newSymbol !== currentSymbol) {
                currentSymbol = newSymbol;
                updateStatus(`Symbol set to ${newSymbol}`, 'success');
                clearAllPatterns();

                // Don't change TradingView chart symbol to avoid invalid symbol errors
                // The scanner will work with the current symbol for pattern detection
            }
        }

        function changeTimeframe() {
            const timeframeSelect = document.querySelector('.tv-timeframe-selector');
            const newTimeframe = timeframeSelect.value;

            if (newTimeframe !== currentTimeframe) {
                currentTimeframe = newTimeframe;
                updateStatus(`Timeframe set to ${newTimeframe}`, 'success');
                clearAllPatterns();

                // Don't change TradingView chart timeframe to avoid issues
                // The scanner will use the selected timeframe for pattern detection
            }
        }

        async function scanGartleyPatterns() {
            if (isScanning) {
                updateStatus('Scanner is busy, please wait...', 'info');
                return;
            }

            isScanning = true;
            const scanBtn = document.querySelector('.tv-gartley-btn');
            scanBtn.classList.add('scanning');
            scanBtn.innerHTML = '<span class="tv-spinner"></span>Scanning...';

            try {
                const patterns = await gartleyDetector.detectGartleyPatterns(currentSymbol, currentTimeframe);

                // Clear previous patterns
                clearAllPatterns();

                // Draw new patterns (limit to top 3 for clarity)
                const topPatterns = patterns.slice(0, 3);
                for (const pattern of topPatterns) {
                    await drawGartleyPattern(pattern);
                }

                // Show results
                displayResults(patterns);

            } catch (error) {
                console.error('Scanning error:', error);
                updateStatus(`Scan error: ${error.message}`, 'error');
            } finally {
                isScanning = false;
                scanBtn.classList.remove('scanning');
                scanBtn.innerHTML = '🦋 Scan Gartley';
            }
        }

        async function drawGartleyPattern(pattern) {
            if (!widget || !widget.chart()) return;

            const chart = widget.chart();
            const points = pattern.points;

            console.log(`Drawing Gartley pattern:`, pattern);

            try {
                // Draw XABCD lines
                for (let i = 0; i < points.length - 1; i++) {
                    const startPoint = { time: points[i].time, price: points[i].price };
                    const endPoint = { time: points[i + 1].time, price: points[i + 1].price };

                    const shapeId = await chart.createMultipointShape([startPoint, endPoint], {
                        shape: "trend_line",
                        overrides: {
                            linecolor: pattern.color,
                            linewidth: 2,
                            linestyle: 0,
                            transparency: 0,
                            extendRight: false,
                            extendLeft: false
                        },
                        zOrder: "top",
                        lock: false
                    });

                    if (shapeId) shapeIds.push(shapeId);
                }

                // Add XABCD labels
                const labels = ['X', 'A', 'B', 'C', 'D'];
                for (let i = 0; i < points.length; i++) {
                    const labelId = await chart.createMultipointShape([{
                        time: points[i].time,
                        price: points[i].price
                    }], {
                        shape: "text",
                        text: labels[i],
                        overrides: {
                            color: "#FFFFFF",
                            fontsize: 12,
                            bold: true,
                            backgroundColor: pattern.color,
                            backgroundTransparency: 0
                        },
                        zOrder: "top"
                    });

                    if (labelId) shapeIds.push(labelId);
                }

                // Add pattern title
                const direction = pattern.direction === 'Bullish' ? '🟢' : '🔴';
                const titleId = await chart.createMultipointShape([{
                    time: points[4].time,
                    price: points[4].price
                }], {
                    shape: "text",
                    text: `🦋 Gartley ${direction} (${pattern.confidence.toFixed(0)}%)`,
                    overrides: {
                        color: pattern.color,
                        fontsize: 11,
                        bold: true,
                        backgroundColor: "#131722",
                        backgroundTransparency: 20
                    },
                    zOrder: "top"
                });

                if (titleId) shapeIds.push(titleId);

            } catch (error) {
                console.error('Error drawing pattern:', error);
            }
        }

        function clearAllPatterns() {
            if (widget && widget.chart()) {
                try {
                    widget.chart().removeAllShapes();
                    shapeIds = [];
                    updateStatus('Patterns cleared', 'info');
                    hideResults();
                } catch (error) {
                    console.error('Error clearing patterns:', error);
                }
            }
        }

        function displayResults(patterns) {
            const resultsPanel = document.querySelector('.tv-results-panel');
            const resultsContent = document.querySelector('.tv-results-content');

            if (patterns.length === 0) {
                hideResults();
                return;
            }

            let html = '';
            patterns.forEach((pattern, index) => {
                const direction = pattern.direction === 'Bullish' ? '🟢' : '🔴';
                html += `
						<div class="tv-pattern-card">
							<div class="tv-pattern-title">
								🦋 Gartley Pattern ${direction} ${pattern.direction}
							</div>
							<div class="tv-pattern-details">
								Symbol: ${pattern.symbol} • Timeframe: ${pattern.timeframe}<br>
								D Point: ${pattern.points[4].price.toFixed(pattern.symbol.includes('JPY') ? 3 : 5)}<br>
								AB/XA: ${pattern.ratios.AB_XA.toFixed(3)} (Target: 0.618)<br>
								AD/XA: ${pattern.ratios.AD_XA.toFixed(3)} (Target: 0.786)
							</div>
							<div class="tv-pattern-confidence">${pattern.confidence.toFixed(1)}% Match</div>
						</div>
					`;
            });

            resultsContent.innerHTML = html;
            resultsPanel.style.display = 'block';
        }

        function hideResults() {
            const resultsPanel = document.querySelector('.tv-results-panel');
            resultsPanel.style.display = 'none';
        }

        // Initialize TradingView widget
        function getParameterByName(name) {
            name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
            var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
                results = regex.exec(location.search);
            return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
        }

        function initOnReady() {
            widget = window.tvWidget = new TradingView.widget({
                debug: false,
                fullscreen: true,
                symbol: 'EURUSD', // Use FOREX which supports intraday intervals
                interval: '1H',
                container: "tv_chart_container",
                datafeed: new Datafeeds.UDFCompatibleDatafeed("https://demo-feed-data.tradingview.com"),
                library_path: "charting_library/",
                locale: "en",
                disabled_features: ["use_localstorage_for_settings", "header_symbol_search"],
                enabled_features: ["study_templates"],
                theme: 'dark',
                custom_css_url: 'themed.css',
                overrides: {
                    "paneProperties.background": "#131722",
                    "paneProperties.vertGridProperties.color": "#1e222d",
                    "paneProperties.horzGridProperties.color": "#1e222d",
                    "mainSeriesProperties.candleStyle.upColor": "#4caf50",
                    "mainSeriesProperties.candleStyle.downColor": "#f44336",
                    "mainSeriesProperties.candleStyle.wickUpColor": "#4caf50",
                    "mainSeriesProperties.candleStyle.wickDownColor": "#f44336",
                    "mainSeriesProperties.candleStyle.borderUpColor": "#4caf50",
                    "mainSeriesProperties.candleStyle.borderDownColor": "#f44336"
                }
            });

            widget.onChartReady(() => {
                console.log('TradingView Gartley Scanner Ready');
                updateStatus('Ready - Click Scan to find Gartley patterns on the visible chart', 'success');

                // Set chart symbol in search box
                document.querySelector('.tv-symbol-search').value = 'EURUSD';
                currentSymbol = 'EURUSD';
            });
        } window.addEventListener('DOMContentLoaded', initOnReady, false);
    </script>
</head>

<body>
    <!-- TradingView-style toolbar -->
    <div class="tv-toolbar">
        <div class="tv-logo">TradingView</div>

        <input type="text" class="tv-symbol-search" placeholder="Enter symbol (e.g. EURUSD, BTCUSD)"
            onchange="changeSymbol()" onkeypress="if(event.key==='Enter') changeSymbol()">

        <select class="tv-timeframe-selector" onchange="changeTimeframe()">
            <option value="15">15m</option>
            <option value="30">30m</option>
            <option value="1H" selected>1h</option>
            <option value="4H">4h</option>
            <option value="1D">1D</option>
        </select>

        <button class="tv-gartley-btn" onclick="scanGartleyPatterns()">
            🦋 Scan Gartley
        </button>

        <button class="tv-clear-btn" onclick="clearAllPatterns()">
            Clear
        </button>

        <div class="tv-status">Initializing...</div>
    </div>

    <!-- Chart container -->
    <div id="tv_chart_container"></div>

    <!-- Floating results panel -->
    <div class="tv-results-panel">
        <div class="tv-results-header">
            🦋 Gartley Pattern Results
        </div>
        <div class="tv-results-content">
            <!-- Results will be populated here -->
        </div>
    </div>
</body>

</html>