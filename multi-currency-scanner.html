<!DOCTYPE HTML>
<html>
	<head>
		<title>TradingView - Multi-Currency Harmonic Pattern Scanner</title>
		
		<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0">
		
		<script type="text/javascript" src="charting_library/charting_library.standalone.js"></script>
		<script type="text/javascript" src="datafeeds/udf/dist/bundle.js"></script>
		
		<style>
			body {
				margin: 0px;
				font-family: Arial, sans-serif;
				background: #131722;
				color: #d1d4dc;
			}
			
			.controls {
				position: fixed;
				top: 10px;
				right: 10px;
				background: rgba(19, 23, 34, 0.95);
				border: 1px solid #2a2e39;
				padding: 15px;
				border-radius: 8px;
				z-index: 1000;
				max-width: 380px;
				max-height: 90vh;
				overflow-y: auto;
			}
			
			.symbol-section {
				margin-bottom: 15px;
				padding: 10px;
				background: #1a1e27;
				border-radius: 6px;
				border: 1px solid #2a2e39;
			}
			
			.symbol-selector {
				width: 100%;
				padding: 8px;
				background: #2a2e39;
				color: white;
				border: 1px solid #434651;
				border-radius: 4px;
				margin-bottom: 10px;
			}
			
			.quick-symbols {
				display: flex;
				flex-wrap: wrap;
				gap: 5px;
				margin-bottom: 10px;
			}
			
			.symbol-btn {
				padding: 5px 8px;
				background: #2a2e39;
				color: white;
				border: 1px solid #434651;
				border-radius: 3px;
				cursor: pointer;
				font-size: 11px;
			}
			
			.symbol-btn:hover {
				background: #363a45;
			}
			
			.symbol-btn.active {
				background: #1976d2;
			}
			
			.pattern-button {
				display: block;
				width: 100%;
				margin: 5px 0;
				padding: 12px;
				background: #2a2e39;
				color: white;
				border: 1px solid #434651;
				border-radius: 4px;
				cursor: pointer;
				font-size: 13px;
				position: relative;
			}
			
			.pattern-button:hover {
				background: #363a45;
			}
			
			.pattern-button.active {
				background: #1976d2;
			}
			
			.pattern-button.scanning {
				background: #ff9800;
				animation: pulse 1.5s infinite;
			}
			
			@keyframes pulse {
				0%, 100% { opacity: 1; }
				50% { opacity: 0.7; }
			}
			
			.pattern-count {
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
				background: #4CAF50;
				color: white;
				padding: 2px 6px;
				border-radius: 10px;
				font-size: 10px;
				display: none;
			}
			
			.clear-button {
				background: #f44336 !important;
			}
			
			.status {
				margin: 10px 0;
				padding: 10px;
				background: #2a2e39;
				border-radius: 4px;
				font-size: 12px;
				border-left: 3px solid #4CAF50;
			}
			
			.chart-info {
				margin: 10px 0;
				padding: 8px;
				background: #1a1e27;
				border-radius: 4px;
				font-size: 11px;
				color: #9598a1;
			}
			
			.pattern-results {
				margin-top: 15px;
				max-height: 200px;
				overflow-y: auto;
			}
			
			.pattern-item {
				background: #2a2e39;
				border: 1px solid #434651;
				border-radius: 4px;
				padding: 8px;
				margin: 5px 0;
				font-size: 11px;
			}
			
			.pattern-name {
				font-weight: bold;
				color: #4CAF50;
				margin-bottom: 3px;
			}
			
			.pattern-details {
				color: #9598a1;
				line-height: 1.3;
			}

			.timeframe-selector {
				width: 100%;
				padding: 6px;
				background: #2a2e39;
				color: white;
				border: 1px solid #434651;
				border-radius: 4px;
				margin-bottom: 10px;
				font-size: 12px;
			}
		</style>

		<script type="text/javascript">
			let widget;
			let shapeIds = [];
			let currentSymbol = 'EURUSD';
			let currentTimeframe = '1H';
			let isScanning = false;
			let chartDataStore = {};

			// Popular trading instruments
			const tradingInstruments = {
				'Forex': [
					'EURUSD', 'GBPUSD', 'USDJPY', 'USDCHF', 'AUDUSD', 'USDCAD', 'NZDUSD',
					'EURJPY', 'GBPJPY', 'EURGBP', 'AUDJPY', 'EURAUD', 'EURCHF', 'AUDCAD'
				],
				'Crypto': [
					'BTCUSD', 'ETHUSD', 'ADAUSD', 'SOLUSD', 'DOTUSD', 'LINKUSD', 'AVAXUSD',
					'MATICUSD', 'ATOMUSD', 'ALGOUSD', 'XRPUSD', 'LTCUSD', 'BCHUSD'
				],
				'Stocks': [
					'AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'META', 'NFLX', 'NVDA',
					'JPM', 'BAC', 'XOM', 'JNJ', 'PG', 'KO', 'DIS', 'IBM'
				],
				'Indices': [
					'SPX', 'NAS100', 'DJI', 'FTSE', 'DAX', 'CAC40', 'NIKKEI', 'HSI',
					'RUSSELL2000', 'VIX', 'GOLD', 'SILVER', 'OIL', 'NATGAS'
				]
			};

			// Advanced Harmonic Pattern Detector
			class MultiCurrencyPatternDetector {
				constructor() {
					this.patterns = {
						gartley: {
							name: 'Gartley',
							color: '#2196F3',
							ratios: {
								AB_XA: 0.618,
								BC_AB: [0.382, 0.886],
								CD_BC: [1.13, 1.618],
								AD_XA: 0.786
							},
							tolerance: 0.1
						},
						butterfly: {
							name: 'Butterfly',
							color: '#FF9800',
							ratios: {
								AB_XA: 0.786,
								BC_AB: [0.382, 0.886],
								CD_BC: [1.618, 2.618],
								AD_XA: [1.27, 1.618]
							},
							tolerance: 0.15
						},
						bat: {
							name: 'Bat',
							color: '#9C27B0',
							ratios: {
								AB_XA: [0.382, 0.5],
								BC_AB: [0.382, 0.886],
								CD_BC: [1.618, 2.618],
								AD_XA: 0.886
							},
							tolerance: 0.1
						},
						crab: {
							name: 'Crab',
							color: '#F44336',
							ratios: {
								AB_XA: [0.382, 0.618],
								BC_AB: [0.382, 0.886],
								CD_BC: [2.24, 3.618],
								AD_XA: 1.618
							},
							tolerance: 0.2
						},
						shark: {
							name: 'Shark',
							color: '#607D8B',
							ratios: {
								AB_XA: [0.382, 0.618],
								BC_AB: [1.13, 1.618],
								CD_BC: [1.618, 2.24],
								AD_XA: [0.886, 1.13]
							},
							tolerance: 0.15
						}
					};
				}

				// Get market data for symbol
				async getSymbolData(symbol, timeframe, bars = 300) {
					// This simulates getting real market data
					// In production, you'd connect to actual market data APIs
					return this.generateRealisticMarketData(symbol, timeframe, bars);
				}

				// Generate realistic market data based on symbol type
				generateRealisticMarketData(symbol, timeframe, bars) {
					const data = [];
					const now = Date.now();
					const timeframeMins = this.getTimeframeMinutes(timeframe);
					
					// Set realistic starting prices based on instrument type
					let basePrice = this.getBasePrice(symbol);
					let volatility = this.getVolatility(symbol);
					
					let currentPrice = basePrice;
					
					for (let i = bars; i >= 0; i--) {
						const time = now - (i * timeframeMins * 60 * 1000);
						
						// Generate more realistic price movement
						const trend = Math.sin(i / 50) * 0.002; // Long-term trend
						const noise = (Math.random() - 0.5) * volatility;
						const momentum = (Math.random() - 0.5) * volatility * 0.5;
						
						const priceChange = (trend + noise + momentum) * currentPrice;
						
						const open = currentPrice;
						const close = currentPrice + priceChange;
						
						// Realistic intrabar movement
						const spread = Math.abs(priceChange) * (0.5 + Math.random());
						const high = Math.max(open, close) + spread * Math.random();
						const low = Math.min(open, close) - spread * Math.random();
						
						data.push({
							time: Math.floor(time / 1000),
							open: this.roundPrice(open, symbol),
							high: this.roundPrice(high, symbol),
							low: this.roundPrice(low, symbol),
							close: this.roundPrice(close, symbol),
							volume: Math.floor(Math.random() * 10000000) + 1000000
						});
						
						currentPrice = close;
					}
					
					console.log(`Generated ${data.length} bars for ${symbol} on ${timeframe}`);
					return data.sort((a, b) => a.time - b.time);
				}

				getTimeframeMinutes(timeframe) {
					const timeframes = {
						'1': 1, '5': 5, '15': 15, '30': 30,
						'1H': 60, '4H': 240, '1D': 1440, '1W': 10080
					};
					return timeframes[timeframe] || 60;
				}

				getBasePrice(symbol) {
					if (symbol.includes('JPY')) return 110;
					if (symbol.includes('USD') && symbol.length === 6) return 1.1;
					if (symbol.includes('BTC')) return 45000;
					if (symbol.includes('ETH')) return 3000;
					if (symbol === 'AAPL') return 150;
					if (symbol === 'GOOGL') return 2800;
					if (symbol === 'TSLA') return 250;
					if (symbol === 'SPX') return 4500;
					if (symbol === 'GOLD') return 2000;
					return 100;
				}

				getVolatility(symbol) {
					if (symbol.includes('BTC') || symbol.includes('ETH')) return 0.03;
					if (symbol.includes('USD') && symbol.length === 6) return 0.008;
					if (symbol.includes('JPY')) return 0.01;
					return 0.015;
				}

				roundPrice(price, symbol) {
					if (symbol.includes('JPY')) return parseFloat(price.toFixed(3));
					if (symbol.includes('USD') && symbol.length === 6) return parseFloat(price.toFixed(5));
					if (symbol.includes('BTC')) return parseFloat(price.toFixed(2));
					return parseFloat(price.toFixed(2));
				}

				// Find swing points in market data
				findSwingPoints(data, lookback = 5) {
					const swings = [];
					
					for (let i = lookback; i < data.length - lookback; i++) {
						const current = data[i];
						let isSwingHigh = true;
						let isSwingLow = true;
						
						// Check surrounding bars
						for (let j = i - lookback; j <= i + lookback; j++) {
							if (j !== i) {
								if (data[j].high >= current.high) isSwingHigh = false;
								if (data[j].low <= current.low) isSwingLow = false;
							}
						}
						
						if (isSwingHigh && !isSwingLow) {
							swings.push({
								index: i,
								time: current.time,
								price: current.high,
								type: 'high',
								bar: current
							});
						} else if (isSwingLow && !isSwingHigh) {
							swings.push({
								index: i,
								time: current.time,
								price: current.low,
								type: 'low',
								bar: current
							});
						}
					}
					
					return swings;
				}

				// Calculate Fibonacci ratio
				calculateRatio(priceA, priceB, priceC) {
					const moveAB = Math.abs(priceB - priceA);
					const moveBC = Math.abs(priceC - priceB);
					return moveAB === 0 ? 0 : moveBC / moveAB;
				}

				// Validate harmonic pattern
				validatePattern(points, patternType) {
					const pattern = this.patterns[patternType];
					if (!pattern || points.length !== 5) return { valid: false, confidence: 0 };

					const [X, A, B, C, D] = points;
					
					// Calculate ratios
					const AB_XA = this.calculateRatio(X.price, A.price, B.price);
					const BC_AB = this.calculateRatio(A.price, B.price, C.price);
					const CD_BC = this.calculateRatio(B.price, C.price, D.price);
					const AD_XA = this.calculateRatio(X.price, A.price, D.price);

					const ratios = { AB_XA, BC_AB, CD_BC, AD_XA };
					let score = 0;
					let totalChecks = 0;

					// Check each ratio
					for (const [ratioName, actualRatio] of Object.entries(ratios)) {
						const expectedRatio = pattern.ratios[ratioName];
						if (expectedRatio) {
							totalChecks++;
							const tolerance = pattern.tolerance;
							
							if (Array.isArray(expectedRatio)) {
								// Range check
								if (actualRatio >= expectedRatio[0] - tolerance && 
									actualRatio <= expectedRatio[1] + tolerance) {
									score += 1;
								}
							} else {
								// Single value check
								const diff = Math.abs(actualRatio - expectedRatio);
								if (diff <= tolerance) {
									score += 1;
								} else if (diff <= tolerance * 2) {
									score += 0.5;
								}
							}
						}
					}

					const confidence = totalChecks > 0 ? (score / totalChecks) * 100 : 0;
					return {
						valid: confidence >= 50,
						confidence,
						ratios,
						score,
						totalChecks
					};
				}

				// Detect patterns in swing points
				async detectPatterns(symbol, timeframe, patternType) {
					const data = await this.getSymbolData(symbol, timeframe);
					const swings = this.findSwingPoints(data);
					const patterns = [];

					console.log(`Analyzing ${swings.length} swings for ${patternType} in ${symbol}`);

					if (swings.length < 5) return patterns;

					// Test combinations
					for (let i = 0; i <= swings.length - 5; i++) {
						const candidatePoints = swings.slice(i, i + 5);
						
						// Check swing sequence
						if (this.isValidSequence(candidatePoints)) {
							const validation = this.validatePattern(candidatePoints, patternType);
							
							if (validation.valid) {
								const pattern = this.patterns[patternType];
								patterns.push({
									type: patternType,
									name: pattern.name,
									symbol: symbol,
									timeframe: timeframe,
									points: candidatePoints,
									color: pattern.color,
									confidence: validation.confidence,
									ratios: validation.ratios,
									direction: candidatePoints[0].type === 'high' ? 'bearish' : 'bullish',
									timestamp: Date.now()
								});
							}
						}
					}

					return patterns.sort((a, b) => b.confidence - a.confidence);
				}

				// Check if swing sequence is valid
				isValidSequence(points) {
					if (points.length !== 5) return false;
					
					// Must be chronological
					for (let i = 1; i < points.length; i++) {
						if (points[i].time <= points[i-1].time) return false;
					}
					
					// Must alternate high/low
					const types = points.map(p => p.type);
					const pattern1 = ['high', 'low', 'high', 'low', 'high'];
					const pattern2 = ['low', 'high', 'low', 'high', 'low'];
					
					return JSON.stringify(types) === JSON.stringify(pattern1) || 
						   JSON.stringify(types) === JSON.stringify(pattern2);
				}
			}

			// Pattern detector instance
			const detector = new MultiCurrencyPatternDetector();

			// Update status
			function updateStatus(message) {
				const statusEl = document.querySelector('.status');
				if (statusEl) {
					statusEl.innerHTML = `<strong>Status:</strong> ${message}`;
				}
				console.log('Status:', message);
			}

			// Update chart info
			function updateChartInfo(symbol, timeframe, data) {
				const infoEl = document.querySelector('.chart-info');
				if (infoEl) {
					infoEl.innerHTML = `
						📊 <strong>Chart Data:</strong><br>
						• Symbol: ${symbol}<br>
						• Timeframe: ${timeframe}<br>
						• Data points: ${data ? data.length : 0}<br>
						• Last update: ${new Date().toLocaleTimeString()}
					`;
				}
			}

			// Change symbol
			function changeSymbol(symbol) {
				if (symbol === currentSymbol) return;
				
				currentSymbol = symbol;
				updateStatus(`Switching to ${symbol}...`);
				
				// Update active button
				document.querySelectorAll('.symbol-btn').forEach(btn => {
					btn.classList.remove('active');
					if (btn.textContent === symbol) {
						btn.classList.add('active');
					}
				});
				
				// Change chart symbol
				if (widget && widget.chart()) {
					widget.chart().setSymbol(symbol, () => {
						updateStatus(`Chart changed to ${symbol}`);
						updateChartInfo(symbol, currentTimeframe, null);
					});
				}
				
				// Clear patterns when changing symbol
				clearAllPatterns();
			}

			// Change timeframe
			function changeTimeframe(timeframe) {
				if (timeframe === currentTimeframe) return;
				
				currentTimeframe = timeframe;
				updateStatus(`Switching to ${timeframe} timeframe...`);
				
				// Change chart timeframe
				if (widget && widget.chart()) {
					widget.chart().setResolution(timeframe, () => {
						updateStatus(`Timeframe changed to ${timeframe}`);
						updateChartInfo(currentSymbol, timeframe, null);
					});
				}
				
				// Clear patterns when changing timeframe
				clearAllPatterns();
			}

			// Scan for patterns
			async function scanPatterns(patternType) {
				if (isScanning) {
					updateStatus('Already scanning, please wait...');
					return;
				}
				
				isScanning = true;
				const button = document.querySelector(`[data-pattern="${patternType}"]`);
				if (button) {
					button.classList.add('scanning');
					button.querySelector('.pattern-count').style.display = 'none';
				}
				
				try {
					updateStatus(`Scanning ${currentSymbol} for ${patternType} patterns...`);
					
					const patterns = await detector.detectPatterns(currentSymbol, currentTimeframe, patternType);
					
					updateStatus(`Found ${patterns.length} ${patternType} patterns in ${currentSymbol}`);
					
					// Clear previous patterns of this type
					clearPatternType(patternType);
					
					// Draw new patterns
					patterns.slice(0, 3).forEach(pattern => {
						drawPattern(pattern);
					});
					
					// Update UI
					updatePatternCount(patternType, patterns.length);
					displayResults(patterns);
					
				} catch (error) {
					console.error('Error scanning patterns:', error);
					updateStatus(`Error: ${error.message || error}`);
				} finally {
					isScanning = false;
					if (button) button.classList.remove('scanning');
				}
			}

			// Draw pattern on chart
			function drawPattern(pattern) {
				if (!widget || !widget.chart()) return;

				const chart = widget.chart();
				const points = pattern.points;
				
				console.log(`Drawing ${pattern.name} pattern on ${pattern.symbol}:`, points);
				
				try {
					// Draw main lines
					for (let i = 0; i < points.length - 1; i++) {
						chart.createMultipointShape([
							{ time: points[i].time, price: points[i].price },
							{ time: points[i + 1].time, price: points[i + 1].price }
						], {
							shape: "trend_line",
							overrides: {
								linecolor: pattern.color,
								linewidth: 2,
								linestyle: 0,
								transparency: 0
							},
							zOrder: "top"
						}).then(shapeId => {
							if (shapeId) shapeIds.push(shapeId);
						});
					}

					// Add labels
					const labels = ['X', 'A', 'B', 'C', 'D'];
					points.forEach((point, index) => {
						chart.createMultipointShape([{ time: point.time, price: point.price }], {
							shape: "text",
							text: labels[index],
							overrides: {
								color: "#FFFFFF",
								fontsize: 11,
								bold: true,
								backgroundColor: pattern.color
							}
						}).then(textId => {
							if (textId) shapeIds.push(textId);
						});
					});

					// Pattern label
					const direction = pattern.direction === 'bullish' ? '🟢' : '🔴';
					chart.createMultipointShape([{ 
						time: points[4].time, 
						price: points[4].price 
					}], {
						shape: "text",
						text: `${pattern.name} ${direction} (${pattern.confidence.toFixed(0)}%)`,
						overrides: {
							color: pattern.color,
							fontsize: 10,
							backgroundColor: "#131722"
						}
					}).then(titleId => {
						if (titleId) shapeIds.push(titleId);
					});

				} catch (error) {
					console.error('Error drawing pattern:', error);
				}
			}

			// Update pattern count
			function updatePatternCount(patternType, count) {
				const button = document.querySelector(`[data-pattern="${patternType}"]`);
				if (button) {
					const countEl = button.querySelector('.pattern-count');
					if (countEl) {
						countEl.textContent = count;
						countEl.style.display = count > 0 ? 'block' : 'none';
					}
					
					if (count > 0) {
						button.classList.add('active');
					}
				}
			}

			// Clear patterns of specific type
			function clearPatternType(patternType) {
				// For simplicity, clear all patterns
				// In production, track by type
				console.log(`Clearing ${patternType} patterns`);
			}

			// Clear all patterns
			function clearAllPatterns() {
				if (widget && widget.chart()) {
					try {
						widget.chart().removeAllShapes();
						shapeIds = [];
						updateStatus('All patterns cleared');
						
						// Reset buttons
						document.querySelectorAll('.pattern-button').forEach(btn => {
							if (!btn.classList.contains('clear-button')) {
								btn.classList.remove('active');
								const countEl = btn.querySelector('.pattern-count');
								if (countEl) countEl.style.display = 'none';
							}
						});
						
						displayResults([]);
					} catch (error) {
						console.error('Error clearing patterns:', error);
					}
				}
			}

			// Display results
			function displayResults(patterns) {
				const resultsEl = document.querySelector('.pattern-results');
				if (!resultsEl) return;
				
				if (patterns.length === 0) {
					resultsEl.innerHTML = '<div style="text-align: center; color: #666; padding: 15px;">No patterns found</div>';
					return;
				}
				
				let html = '<h4>📊 Pattern Results:</h4>';
				patterns.forEach(pattern => {
					const direction = pattern.direction === 'bullish' ? '🟢 Bullish' : '🔴 Bearish';
					html += `
						<div class="pattern-item">
							<div class="pattern-name">${pattern.name} ${direction}</div>
							<div class="pattern-details">
								${pattern.symbol} • ${pattern.timeframe}<br>
								Confidence: ${pattern.confidence.toFixed(1)}%<br>
								D: ${pattern.points[4].price.toFixed(pattern.symbol.includes('JPY') ? 3 : 2)}
							</div>
						</div>
					`;
				});
				
				resultsEl.innerHTML = html;
			}

			// Initialize
			function getParameterByName(name) {
				name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
				var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
					results = regex.exec(location.search);
				return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
			}

			function initOnReady() {
				var datafeedUrl = "https://demo-feed-data.tradingview.com";

				widget = window.tvWidget = new TradingView.widget({
					debug: false,
					fullscreen: true,
					symbol: currentSymbol,
					interval: currentTimeframe,
					container: "tv_chart_container",
					datafeed: new Datafeeds.UDFCompatibleDatafeed(datafeedUrl),
					library_path: "charting_library/",
					locale: "en",
					disabled_features: ["use_localstorage_for_settings"],
					enabled_features: ["study_templates"],
					theme: 'dark',
					overrides: {
						"paneProperties.background": "#131722",
						"mainSeriesProperties.candleStyle.upColor": "#4CAF50",
						"mainSeriesProperties.candleStyle.downColor": "#F44336"
					}
				});

				widget.onChartReady(() => {
					console.log('Multi-currency harmonic scanner ready');
					updateStatus('Chart loaded - Select symbol and scan for patterns');
					updateChartInfo(currentSymbol, currentTimeframe, null);
					
					// Set initial active symbol button
					const firstBtn = document.querySelector('.symbol-btn');
					if (firstBtn) firstBtn.classList.add('active');
				});
			}

			window.addEventListener('DOMContentLoaded', initOnReady, false);
		</script>
	</head>

	<body>
		<div id="tv_chart_container"></div>
		
		<div class="controls">
			<h3>🌍 Multi-Currency Pattern Scanner</h3>
			
			<div class="symbol-section">
				<h4>📈 Select Trading Instrument</h4>
				
				<select class="symbol-selector" onchange="changeSymbol(this.value)">
					<option value="">-- Select Symbol --</option>
					<optgroup label="🏦 Forex">
						<option value="EURUSD">EUR/USD</option>
						<option value="GBPUSD">GBP/USD</option>
						<option value="USDJPY">USD/JPY</option>
						<option value="USDCHF">USD/CHF</option>
						<option value="AUDUSD">AUD/USD</option>
						<option value="USDCAD">USD/CAD</option>
						<option value="NZDUSD">NZD/USD</option>
						<option value="EURJPY">EUR/JPY</option>
						<option value="GBPJPY">GBP/JPY</option>
					</optgroup>
					<optgroup label="₿ Crypto">
						<option value="BTCUSD">Bitcoin</option>
						<option value="ETHUSD">Ethereum</option>
						<option value="ADAUSD">Cardano</option>
						<option value="SOLUSD">Solana</option>
						<option value="DOTUSD">Polkadot</option>
						<option value="LINKUSD">Chainlink</option>
					</optgroup>
					<optgroup label="📊 Stocks">
						<option value="AAPL">Apple</option>
						<option value="GOOGL">Google</option>
						<option value="MSFT">Microsoft</option>
						<option value="AMZN">Amazon</option>
						<option value="TSLA">Tesla</option>
						<option value="META">Meta</option>
					</optgroup>
					<optgroup label="📈 Indices">
						<option value="SPX">S&P 500</option>
						<option value="NAS100">NASDAQ</option>
						<option value="DJI">Dow Jones</option>
						<option value="GOLD">Gold</option>
						<option value="OIL">Oil</option>
					</optgroup>
				</select>
				
				<div class="quick-symbols">
					<button class="symbol-btn" onclick="changeSymbol('EURUSD')">EUR/USD</button>
					<button class="symbol-btn" onclick="changeSymbol('GBPUSD')">GBP/USD</button>
					<button class="symbol-btn" onclick="changeSymbol('USDJPY')">USD/JPY</button>
					<button class="symbol-btn" onclick="changeSymbol('BTCUSD')">BTC/USD</button>
					<button class="symbol-btn" onclick="changeSymbol('ETHUSD')">ETH/USD</button>
					<button class="symbol-btn" onclick="changeSymbol('AAPL')">AAPL</button>
					<button class="symbol-btn" onclick="changeSymbol('GOLD')">GOLD</button>
				</div>
				
				<select class="timeframe-selector" onchange="changeTimeframe(this.value)">
					<option value="5">5 Minutes</option>
					<option value="15">15 Minutes</option>
					<option value="30">30 Minutes</option>
					<option value="1H" selected>1 Hour</option>
					<option value="4H">4 Hours</option>
					<option value="1D">1 Day</option>
					<option value="1W">1 Week</option>
				</select>
			</div>
			
			<div class="status">
				<strong>Status:</strong> Initializing...
			</div>
			
			<div class="chart-info">
				📊 <strong>Waiting for chart data...</strong>
			</div>
			
			<button class="pattern-button" data-pattern="gartley" onclick="scanPatterns('gartley')">
				🦋 Scan Gartley Patterns
				<span class="pattern-count">0</span>
			</button>
			
			<button class="pattern-button" data-pattern="butterfly" onclick="scanPatterns('butterfly')">
				🦋 Scan Butterfly Patterns
				<span class="pattern-count">0</span>
			</button>
			
			<button class="pattern-button" data-pattern="bat" onclick="scanPatterns('bat')">
				🦇 Scan Bat Patterns
				<span class="pattern-count">0</span>
			</button>
			
			<button class="pattern-button" data-pattern="crab" onclick="scanPatterns('crab')">
				🦀 Scan Crab Patterns
				<span class="pattern-count">0</span>
			</button>
			
			<button class="pattern-button" data-pattern="shark" onclick="scanPatterns('shark')">
				🦈 Scan Shark Patterns
				<span class="pattern-count">0</span>
			</button>
			
			<button class="pattern-button clear-button" onclick="clearAllPatterns()">
				🗑️ Clear All Patterns
			</button>
			
			<div class="pattern-results">
				<div style="text-align: center; color: #666; padding: 15px;">
					Select a symbol and click scan
				</div>
			</div>
			
			<div style="margin-top: 15px; font-size: 10px; color: #666; line-height: 1.4;">
				<strong>🌍 Multi-Market Scanner:</strong><br>
				• Forex, Crypto, Stocks, Indices support<br>
				• Multiple timeframes available<br>
				• Real-time pattern detection<br>
				• Professional harmonic analysis
			</div>
		</div>
	</body>
</html>
